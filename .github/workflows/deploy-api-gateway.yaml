name: Deploy API Gateway

on:
  push:
    branches: [main, dev]
    paths:
      - "services/**/openapi.yaml"
      - "services/**/config.json"
      - "api-gateway/**"
      - "scripts/aggregate-openapi.js"
      - "scripts/prepare-api-deployment.js"
      - "scripts/generate-service-registry.js"
      - ".github/workflows/deploy-api-gateway.yml"
  workflow_dispatch:
    inputs:
      stage:
        description: "Deployment stage"
        required: true
        default: "dev"
        type: choice
        options:
          - dev
          - prod

jobs:
  set-environment:
    runs-on: ubuntu-latest
    outputs:
      stage: ${{ steps.set-stage.outputs.stage }}
    steps:
      - name: Set deployment stage
        id: set-stage
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "stage=${{ github.event.inputs.stage }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "stage=prod" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/dev" ]]; then
            echo "stage=dev" >> $GITHUB_OUTPUT
          else
            echo "Unknown branch"
            exit 1
          fi

  validate-services:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: "18"

      - name: Install dependencies
        run: |
          npm install js-yaml glob

      - name: Generate service registry
        run: |
          echo "üîÑ Generating service registry for API Gateway..."
          node scripts/generate-service-registry.js

      - name: Validate service configurations
        run: |
          echo "üîç Validating service configurations..."

          # Function to check if directory is a service
          is_service_directory() {
            local dir=$1
            # A service directory must have config.json AND (index.js OR index.py)
            if [ -f "$dir/config.json" ] && ([ -f "$dir/index.js" ] || [ -f "$dir/index.py" ]); then
              return 0  # true
            else
              return 1  # false
            fi
          }

          # Check that all services have required files
          service_count=0
          for service_dir in services/*/; do
            if [ -d "$service_dir" ]; then
              service_name=$(basename "$service_dir")
              
              # Only validate if it's actually a service directory
              if is_service_directory "$service_dir"; then
                echo "Validating $service_name..."
                service_count=$((service_count + 1))
                
                # Check required files exist
                if [ ! -f "$service_dir/config.json" ]; then
                  echo "‚ùå Missing config.json in $service_name"
                  exit 1
                fi
                
                if [ ! -f "$service_dir/openapi.yaml" ]; then
                  echo "‚ö†Ô∏è  Missing openapi.yaml in $service_name - will be skipped from API"
                fi
                
                # Validate JSON syntax
                if ! jq empty "$service_dir/config.json" 2>/dev/null; then
                  echo "‚ùå Invalid JSON in $service_name/config.json"
                  exit 1
                fi
                
                echo "‚úÖ $service_name is valid"
              else
                echo "‚è≠Ô∏è  Skipping $service_name (not a service - missing config.json or handler)"
              fi
            fi
          done

          echo "üìä Found $service_count services to validate"
          echo "üîç Services found:"
          for service_dir in services/*/; do
            if [ -d "$service_dir" ]; then
              service_name=$(basename "$service_dir")
              if is_service_directory "$service_dir"; then
                echo "  ‚úÖ $service_name"
              else
                echo "  ‚è≠Ô∏è  $service_name (not a service)"
              fi
            fi
          done

      - name: Test OpenAPI aggregation
        run: |
          echo "üß™ Testing OpenAPI aggregation..."
          node scripts/aggregate-openapi.js --output test-aggregated.yaml

          if [ ! -f "test-aggregated.yaml" ]; then
            echo "‚ùå OpenAPI aggregation failed"
            exit 1
          fi

          echo "‚úÖ OpenAPI aggregation test passed"

  check-custom-authorizer:
    needs: set-environment
    runs-on: ubuntu-latest
    env:
      STAGE: ${{ needs.set-environment.outputs.stage }}
    steps:
      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-region: eu-west-2
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Check Custom Authorizer Exists
        run: |
          echo "üîç Checking if custom authorizer exists for stage: ${STAGE}"

          FUNCTION_NAME="truss-custom-authorizer-${STAGE}"

          if aws lambda get-function --function-name "${FUNCTION_NAME}" >/dev/null 2>&1; then
            echo "‚úÖ Custom authorizer function exists: ${FUNCTION_NAME}"
            
            # Get the function ARN
            FUNCTION_ARN=$(aws lambda get-function --function-name "${FUNCTION_NAME}" --query 'Configuration.FunctionArn' --output text)
            echo "üìç Function ARN: ${FUNCTION_ARN}"
            echo "‚úÖ Custom authorizer is available for use"
          else
            echo "‚ö†Ô∏è  Custom authorizer function not found: ${FUNCTION_NAME}"
            echo "üîß You may need to deploy the custom authorizer first:"
            echo "   Run the 'Deploy Custom Authorizer' workflow"
            echo "   Or manually deploy with: aws cloudformation deploy --stack-name truss-custom-authorizer-${STAGE}"
            
            # Don't fail the build, just warn
            echo "‚è≠Ô∏è  Continuing with API Gateway deployment (services may use direct Cognito auth as fallback)"
          fi

  deploy-api-gateway:
    needs: [set-environment, validate-services, check-custom-authorizer]
    runs-on: ubuntu-latest
    env:
      STAGE: ${{ needs.set-environment.outputs.stage }}
    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: "18"

      - name: Install dependencies
        run: |
          npm install js-yaml glob

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-region: eu-west-2
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Generate service registry for API Gateway
        run: |
          echo "üîÑ Generating service registry for API Gateway deployment..."
          node scripts/generate-service-registry.js

          # Verify registry was created
          if [ -f "api-gateway/service-registry.json" ]; then
            echo "‚úÖ Service registry created for API Gateway"
            jq '.services | length' api-gateway/service-registry.json
            echo "services found in API Gateway registry"
          else
            echo "‚ö†Ô∏è  No API Gateway registry found, but continuing..."
          fi

      - name: Wait for service deployments
        run: |
          echo "‚è≥ Waiting for service Lambda deployments to complete..."

          # Function to check if directory is a service
          is_service_directory() {
            local dir=$1
            if [ -f "$dir/config.json" ] && ([ -f "$dir/index.js" ] || [ -f "$dir/index.py" ]); then
              return 0
            else
              return 1
            fi
          }

          # Get list of actual services only (recursively)
          services=""
          while IFS= read -r -d '' config_file; do
            service_dir=$(dirname "$config_file")
            if is_service_directory "$service_dir"; then
              # Create flattened service name (e.g., meta/routes -> meta-routes)
              relative_path="${service_dir#services/}"
              flattened_name=$(echo "$relative_path" | tr '/' '-')
              services="$services $flattened_name"
            fi
          done < <(find services/ -name "config.json" -type f -print0)

          for service in $services; do
            stack_name="truss-annotation-intelligent-function-${service}-${STAGE}"
            echo "Checking stack: $stack_name"
            
            # Wait for stack to be in stable state
            aws cloudformation wait stack-create-complete --stack-name $stack_name 2>/dev/null || \
            aws cloudformation wait stack-update-complete --stack-name $stack_name 2>/dev/null || \
            echo "Stack $stack_name already in stable state or doesn't exist"
          done

      - name: Prepare API Gateway deployment
        run: |
          echo "üöÄ Preparing API Gateway deployment for stage: ${STAGE}"

          # Run the preparation script with error handling
          if ! node scripts/prepare-api-deployment.js --stage=${STAGE}; then
            echo "‚ùå API preparation script failed"
            exit 1
          fi

          # Verify the outputs were created
          echo "‚úÖ Checking preparation outputs..."

          if [ ! -f "api-gateway/template-${STAGE}.yaml" ]; then
            echo "‚ùå API Gateway template not generated"
            exit 1
          fi

          if [ ! -f "api-gateway/deployment-ready-${STAGE}.yaml" ]; then
            echo "‚ùå Deployment-ready spec not generated"
            exit 1
          fi

          # Verify S3 upload
          echo "üîç Verifying S3 upload..."
          if ! aws s3 ls "s3://truss-api-automated-deployments/api-specs/deployment-ready-${STAGE}.yaml"; then
            echo "‚ùå Deployment spec not found in S3, attempting manual upload..."
            aws s3 cp "api-gateway/deployment-ready-${STAGE}.yaml" "s3://truss-api-automated-deployments/api-specs/deployment-ready-${STAGE}.yaml"
          fi

          echo "‚úÖ API Gateway preparation complete"

      - name: Deploy API Gateway
        run: |
          STACK_NAME="truss-annotation-intelligent-function-api-${STAGE}"
          TEMPLATE_FILE="api-gateway/template-${STAGE}.yaml"

          echo "üöÄ Deploying API Gateway stack: $STACK_NAME"

          # Deploy using S3 bucket for large templates
          aws cloudformation deploy \
            --stack-name $STACK_NAME \
            --template-file $TEMPLATE_FILE \
            --parameter-overrides StageName=${STAGE} \
            --capabilities CAPABILITY_NAMED_IAM CAPABILITY_AUTO_EXPAND \
            --no-fail-on-empty-changeset \
            --s3-bucket truss-api-automated-deployments

      - name: Get API Gateway URL
        id: get-url
        run: |
          API_URL=$(aws cloudformation describe-stacks \
            --stack-name "truss-annotation-intelligent-function-api-${STAGE}" \
            --query "Stacks[0].Outputs[?OutputKey=='ApiGatewayUrl'].OutputValue" \
            --output text)

          echo "api_url=$API_URL" >> $GITHUB_OUTPUT
          echo "API_URL=$API_URL" >> $GITHUB_ENV

      - name: Output deployment summary
        run: |
          echo "üéâ API Gateway Deployment Complete!"
          echo "üìç Stage: ${STAGE}"
          echo "üîó API URL: ${{ steps.get-url.outputs.api_url }}"
          echo ""
          echo "üìä Deployment Summary:"

          # Function to check if directory is a service
          is_service_directory() {
            local dir=$1
            if [ -f "$dir/config.json" ] && ([ -f "$dir/index.js" ] || [ -f "$dir/index.py" ]); then
              return 0
            else
              return 1
            fi
          }

          # List all deployed services (recursively)
          services=""
          service_count=0
          while IFS= read -r -d '' config_file; do
            service_dir=$(dirname "$config_file")
            if is_service_directory "$service_dir"; then
              relative_path="${service_dir#services/}"
              flattened_name=$(echo "$relative_path" | tr '/' '-')
              services="$services $flattened_name"
              service_count=$((service_count + 1))
            fi
          done < <(find services/ -name "config.json" -type f -print0)

          echo "   - Services deployed: $service_count"
          echo "   - Services:"
          for service in $services; do
            if [ "$service" = "automated-annotation" ]; then
              echo "     * $service (LangChain-powered AI service)"
            else
              echo "     * $service"
            fi
          done

          # Check if custom authorizer is being used
          CUSTOM_AUTH_FUNCTION="truss-custom-authorizer-${STAGE}"
          if aws lambda get-function --function-name "${CUSTOM_AUTH_FUNCTION}" >/dev/null 2>&1; then
            echo "   - Custom Authorizer: ‚úÖ Active (${CUSTOM_AUTH_FUNCTION})"
            echo "   - Multi-Cognito Support: ‚úÖ Enabled"
          else
            echo "   - Custom Authorizer: ‚ö†Ô∏è  Not deployed"
            echo "   - Multi-Cognito Support: ‚ùå Using direct Cognito integration"
          fi

          echo ""
          echo "üîó Available Endpoints:"
          echo "   Base URL: ${{ steps.get-url.outputs.api_url }}"

          # Extract endpoints from aggregated spec
          if [ -f "api-gateway/aggregated-openapi-${STAGE}.yaml" ]; then
            echo "   Paths discovered:"
            grep "^  /" "api-gateway/aggregated-openapi-${STAGE}.yaml" | head -10 | sed 's/^/     /'
            
            total_paths=$(grep -c "^  /" "api-gateway/aggregated-openapi-${STAGE}.yaml" || echo "0")
            echo "   Total paths: $total_paths"
            
            # Highlight automated annotation endpoints
            if grep -q "/automations/annotation" "api-gateway/aggregated-openapi-${STAGE}.yaml"; then
              echo ""
              echo "ü§ñ Automated Annotation Endpoints:"
              grep "/automations/annotation" "api-gateway/aggregated-openapi-${STAGE}.yaml" | sed 's/^/     /'
            fi
          fi

          echo ""
          echo "üìö API Documentation:"
          echo "   Swagger UI: ${{ steps.get-url.outputs.api_url }}/swagger"
          echo "   OpenAPI Spec: ${{ steps.get-url.outputs.api_url }}/openapi.json"

  notify-deployment:
    needs: [deploy-api-gateway, set-environment]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Notify deployment status
        run: |
          if [[ "${{ needs.deploy-api-gateway.result }}" == "success" ]]; then
            echo "‚úÖ API Gateway deployment successful for stage: ${{ needs.set-environment.outputs.stage }}"
          else
            echo "‚ùå API Gateway deployment failed for stage: ${{ needs.set-environment.outputs.stage }}"
            exit 1
          fi
